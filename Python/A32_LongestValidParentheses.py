class Solution:
    # @param {string} s
    # @return {integer}
    # dp[i][j] denotes if substring is valid parthenses from i to j in s
    # dp from dp[i][i+1] = s[i] == '(' and s[i + 1] == ')'
    # valid parenthese after that may be '()' + a valid parenth
    # or '(' + a valid parenth + ')'
    # so for dp[i][j] (j - i >= 3), it should be :
    #       dp[i + 1][j - 1] and s[i] == '(' and s[j] == ')'
    #    or dp[i][j - 2] and s[j - 1] == '(' and s[j] == ')'
    #    or dp[i - 2][j] and s[i - 2] == '(' and s[i - 1] == ')'
    #   above TLE
    #   
    #   stack:
    #   if(valid parentheses) 
    def longestValidParentheses(self, s):
        stack = []
        res = 0
        l = 0
        for i in xrange(len(s)):
            c = s[i]
            if(c == '('): 
                stack.append(i)
            else:
                # print stack
                if(len(stack) > 0 and s[stack[-1]] == '('):
                    stack.pop()
                    if(len(stack) == 0): 
                        l = i + 1
                    else:
                        l = i - stack[-1]
                    res = max(res, l)
                else: 
                    stack.append(i)
        if(len(stack) > 1): res = max(i - stack.pop() - 1, res)
        return res
    # accepted solution
    # this is very similar with histogram problem

    # def longestValidParentheses2(self, s):
    #     dp = [[False for x in range(len(s))] for y in range(len(s))]
    #     res = 0
    #     for i in xrange(len(s) - 1):
    #         dp[i][i + 1] = (s[i] == '(')  and (s[i + 1] == ')')
    #         if(res == 0 and dp[i][i + 1]): res = 1
    #     l = 3
    #     while(l < len(s)):
    #         for i in xrange(len(s) - l):
    #             j = i + l
    #             outter = dp[i + 1][j - 1] and s[i] == '(' and s[j] == ')'
    #             right = dp[i][j - 2] and s[j - 1] == '(' and s[j] == ')'
    #             left = dp[i - 2][j] and s[i - 2] == '(' and s[i - 1] == ')'
    #             dp[i][j] = outter or right or left
    #             if(dp[i][j]): res = max(res, j - i + 1)
    #         l += 2
    #     return res
s = Solution()
st2 = "())()()(())((()(()()(((()))((((())((()(())()())(()((((()))()(()))(())()(())(()(((((())((((((()())())(()(()((())()))(()))))))()(()))((((())()()()))()()()(((()(()())(()()(()(()()(((()))))))()()))())())((()()))))))((()))(((()((())()(()()))((())))()()())))))))()))))(()))))()))()))()((())))((()))(()))))))(((()))))))))()(()()()(())((())()))()()(())))()()))(()())()))(((()())()))((())((((()))(()(()(()()()(((())()(((((()))((()(((((())(()()))((((((((()(()(()(()(())))(())(()())())(()((((()(())((()(())))(())))()(((((()(()()(())))))))())(())(())(()()(((())))((()))(((((()))))())))()((()))()))))())))))((())(((((()()))((((())))(((()(()(())())(((()(()(()()()())))())()))((()((())())()()()(((())(((((()((((((()((()())))((((())((()(((((((()(()((()()()(()(()())(()(()()((((())))()(((()())))(()()))()(()()()()(((((())(()))))((()))())))()((((((()))())))()(()))(())))((((()())(((((()()())(((((())(()())(()))))()(()()))()))))))())))(((())(()(()()))(()))()(((())))())((((()(((()))))))()(()(()))()()(()()))))))))((()))))))(())((()((()))()))((((((()())))))(()((())((((()))))(()(()()()()(()))()()(()(()))(()()(((((((()())(())(()())((())())()(()())((())()())())(()())))())))(())())())(())((()())(((()()))()))()()))()(()(())((((((((())))()((())((()((((((((((()))))(()(((((())(()(()())())))((())())))))()))(()((()()))((()((())()()()((()(())())((())())(()()(((())))))())()()(()))()())(()(()((())))((((()()(())))())(())(()(()(())())())(()()())()(())())))(()()(((())))((()()(((())()()(()())((((()()(()())(()((((()(()()(()(()(((()((()())(()()))(()((((()(((((()))))()()))(((()((((((()(()()()()())()))(()(())))))((()(((()())())))(((()()))(()(()(((((((()()))(()(())))())()(())())(())(()))(())(()))()()(()()())))))()))()((())(((()((((((((())()()))())))((()())("
st3 = "())()()(()()())))))(()()()"
st = "()(()"
print s.longestValidParentheses(st2)